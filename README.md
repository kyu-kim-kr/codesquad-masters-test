
# 루빅스 큐빅 구현

## 2단계: 평면 큐브 구현하기
3 X 3  2차원 배열이 아래처럼 있다.
```
R R W
G C W
G B B
```
사용자 입력을 받아서 아래의 동작을 하는 프로그램을 구현하시오
```
> U  가장 윗줄을 왼쪽으로 한 칸 밀기 RRW -> RWR
> U' 가장 윗줄을 오른쪽으로 한 칸 밀기 RRW -> WRR
> R  가장 오른쪽 줄을 위로 한 칸 밀기 WWB -> WBW
> R' 가장 오른쪽 줄을 아래로 한 칸 밀기 WWB -> BWW
> L  가장 왼쪽 줄을 아래로 한 칸 밀기 RGG -> GRG (L의 경우 R과 방향이 반대임을 주의한다.)
> L' 가장 왼쪽 줄을 위로 한 칸 밀기 RGG -> GGR
> B  가장 아랫줄을 오른쪽으로 한 칸 밀기 GBB -> BGB (B의 경우도 U와 방향이 반대임을 주의한다.)
> B' 가장 아랫줄을 왼쪽으로 한 칸 밀기 GBB -> BBG
> Q  Bye~를 출력하고 프로그램을 종료한다.
```
### 요구사항
- 처음 시작하면 초기 상태를 출력한다.
- 간단한 프롬프트 (CLI에서 키보드 입력받기 전에 표시해주는 간단한 글자들 - 예: CUBE> )를 표시해 준다.
- 한 번에 여러 문자를 입력받은 경우 순서대로 처리해서 매 과정을 화면에 출력한다

### 동작 예시
```
R R W
G C W
G B B

CUBE> UUR

U
R W R 
G C W
G B B

U
W R R  
G C W
G B B

R
W R W 
G C B
G B R

CUBE> Q
Bye~
```
## 2단계 코딩 요구사항
- 너무 크지 않은 함수 단위로 구현하려고 노력할 것
- 전역변수의 사용을 자제할 것
- 객체와 배열을 적절히 활용할 것
---
## 코드

### 구조

1. 메인클래스에서 먼저 `Cubic`생성자를 만듭니다
2. 큐브를 계속 돌리기 위해서 while문을 만들고 여러 입력값을 한번에 받기위해서 `split()`을 사용합니다. 그리고 입력값에 따라 `cube`배열을 재선언하는 메소드도 함께 while문에 넣습니다.
3. 배열을 스캔 되어진 값별로 인덱스별로 다시 선언하는 로직을 for문에 넣습니다. for문은 사용자가 입력한 값의 갯수만큼의 배열의 길이까지 반복합니다.
4. 재선언 된 배열을 불러오는 메소드 `printArray()`를 마지막에 넣습니다.
5. Q를 입력하면 시스템이 종료됩니다.

### 코드 설명
요구사항대로 크지 않은 함수 단위와 전역변수 사용을 자제하려 했으나 이렇게 구현하는 것 외에는 딱히 생각나는 방법이 없었습니다.

```java
 for (int i = 0; i < str.length; i++) {
            if (str[i].equals("U")) {
                s = cube[0][0] + cube[0][1] + cube[0][2];
                s = s.substring(1) + s.substring(0, 1);
                cube[0][0] = s.substring(0, 1);
                cube[0][1] = s.substring(1, 2);
                cube[0][2] = s.substring(2, 3);
            }
            printArray();
        }
```
입력받는 문자마다 조건을 주려고 for문을 이용합니다. 먼저 해당되는 라인의 인덱스값들을 String의 substring을 사용하기 위해서 변수에 담아서 한 문자열로 만듭니다. 그런 뒤에 1단계에서 사용한 방식대로 substring을 사용하여 한 칸 밀려진 문자열을 다시 똑같은 변수에 담습니다. 그런 다음에 불러왔던 배열의 인덱스들을 새로운 문자열로 대체하고 배열 전체를 프린트합니다.

이 방식대로 U U' B B' L L' R R' 에 대해서 모두 똑같은 로직으로 만들어줍니다. 

생성자 안에다가 이 로직들이 담긴 메소들을 무한 반복문에 scanner와 함께 넣어주면 끝입니다.



